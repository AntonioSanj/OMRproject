import cv2
import numpy as np

from constants import noteHeadTemplate
from utils.plotUtils import showImage, showCompareImages
from vision.visionUtils import thresh, createKernelFromImage
from vision.noteHeadDetection.noteHeadDetectionOperations import closing, getQuaverBarArea, fillWhiteHoles, \
    findLocalMax, findEnclosedWhiteRegions, cleanLines, cleanCorners, consolidatePoints, drawPoints


def getNoteHead(image, show=False, fileName="Note head detection"):
    og = image.copy()

    # convert to gray scale
    image = np.array(image)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

    image = thresh(image, 160)

    # returns an image of boolean pixels corresponding to the quaver bar.
    quaverBarMask = getQuaverBarArea(image)
    image[quaverBarMask] = 255.  # removes the quaver bar

    # save small white regions for later polish
    smallWhiteAreasMask = findEnclosedWhiteRegions(image, 20)

    # fill white holes because of double class
    image = fillWhiteHoles(image)

    # round edges
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    image = closing(image, kernel)

    # add back small white regions to improve upcoming template matching
    image[smallWhiteAreasMask] = 255.
    # remove the lines generated by inserting the small white areas
    image = cleanLines(image)
    # remove the area in the corner formed by the stick and the stave line
    image = cleanCorners(image)

    # find heads using template
    headTemplate = createKernelFromImage(noteHeadTemplate)
    headTemplate = cv2.bitwise_not(headTemplate)

    # look for note head template match
    headLocations = cv2.matchTemplate(image, headTemplate, cv2.TM_CCOEFF_NORMED)

    noteHeadPoints = findLocalMax(headLocations)

    # when max point is in window border more than two points can be created
    # then, when two points are too close only pick the brightest
    noteHeadPoints = consolidatePoints(noteHeadPoints, 10)

    # translate matching point to center of template
    noteHeadPoints = [((x + headTemplate.shape[1] // 2, y + headTemplate.shape[0] // 2), value) for ((x, y), value) in noteHeadPoints]

    if show:
        drawPoints(noteHeadPoints, og, fileName)
    
    # TODO
    # adjust the kernel template to meangap

    return image
