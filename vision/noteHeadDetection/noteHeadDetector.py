import cv2
import numpy as np

from constants import noteHeadTemplate
from utils.plotUtils import showImage, showCompareImages
from vision.visionUtils import thresh, createKernelFromImage
from vision.noteHeadDetection.noteHeadDetectionOperations import closing, getQuaverBarArea, fillWhiteHoles, \
    findLocalMax, findEnclosedWhiteRegions, cleanLines, cleanCorners, consolidatePoints, drawPoints


def getNoteHead(image, noteType='None', show=False, fileName="Note head detection"):
    og = image.copy()

    # convert to gray scale
    image = np.array(image)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

    image = thresh(image, 160)

    # returns an image of boolean pixels corresponding to the quaver bar.
    quaverBarMask = getQuaverBarArea(image)
    image[quaverBarMask] = 255.  # removes the quaver bar

    smallWhiteAreasMask = np.zeros_like(image, dtype=np.uint8)

    # this conditional part would not be necessary if it weren't because of individual half figures
    # originally it was intended to make the same code for all one, half, quarter and double class
    # this was in order to tolerate classification mistakes

    if noteType == 'double':
        # save small white regions for later polish (whites between the note circle and a corner)
        smallWhiteAreasMask = findEnclosedWhiteRegions(image, 10)

        # fill white holes because of double class
        image = fillWhiteHoles(image)

    # round edges
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    image = closing(image, kernel)

    if noteType == 'double':
        # add back small white regions to improve upcoming template matching
        image[smallWhiteAreasMask] = 255.

    # remove the lines generated by inserting the small white areas
    image = cleanLines(image)
    # remove the area in the corner formed by the stick and the stave line
    image = cleanCorners(image)

    # find heads using template
    headTemplate = createKernelFromImage(noteHeadTemplate)
    headTemplate = cv2.bitwise_not(headTemplate)

    # look for note head template match
    headLocations = cv2.matchTemplate(image, headTemplate, cv2.TM_CCOEFF_NORMED)

    noteHeadPoints = findLocalMax(headLocations, 13, 0.4)

    # when max point is in window border more than two points can be created
    # then, when two points are too close only pick the brightest
    noteHeadPoints = consolidatePoints(noteHeadPoints, 10)

    # translate matching point to center of template
    noteHeadPoints = [((x + headTemplate.shape[1] // 2, y + headTemplate.shape[0] // 2), value) for ((x, y), value) in
                      noteHeadPoints]

    if show:
        drawPoints(noteHeadPoints, og, fileName)

    # adjust the kernel template to meangap if needed

    return image
