import cv2
import numpy as np

from constants import noteHeadTemplate, fourHeadTemplate
from utils.plotUtils import showImage, showCompareImages
from vision.visionUtils import thresh, createKernelFromImage
from vision.noteHeadDetection.noteHeadDetectionOperations import closing, getQuaverBarArea, fillWhiteHoles, \
    findLocalMax, findEnclosedWhiteRegions, cleanLines, removeBlackAreas, consolidatePoints, drawPoints, \
    drawSingleLineUpAndDown, findLocalMaxFour


# getNoteHead works with classes: one, double, half and quarter
def getNoteHeads(image, noteType='None', show=False, debug=False, fileName="Note head detection"):
    og = image.copy()
    showImage(og, 'Original') if debug else None

    # convert to gray scale
    image = np.array(image)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

    image = thresh(image, 160)
    showImage(image, 'Threshold') if debug else None

    # returns an image of boolean pixels corresponding to the quaver bar.
    quaverBarMask = getQuaverBarArea(image)
    image[quaverBarMask] = 255.  # removes the quaver bar
    showImage(image, 'Remove beam') if debug else None

    smallWhiteAreasMask = np.zeros_like(image, dtype=np.uint8)  # not actually needed but prevents a warning

    # this conditional part would not be necessary if it weren't because of individual half figures
    # originally it was intended to make the same code for all one, half, quarter and double class
    # this was in order to tolerate classification mistakes

    if noteType == 'double':
        # save small white regions for later polish (whites between the note circle and a corner)
        smallWhiteAreasMask = findEnclosedWhiteRegions(image, 10)
        showImage(smallWhiteAreasMask, 'Small white areas') if debug else None
        # fill white holes because of double class
        image = fillWhiteHoles(image)
        showImage(image, 'Filled white holes') if debug else None

    # round edges
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    image = closing(image, kernel)
    showImage(image, 'Round edges closing') if debug else None

    if noteType == 'double':
        # add back small white regions to improve upcoming template matching
        image[smallWhiteAreasMask] = 255.
        showImage(image, 'Add back small white areas')

    # remove the lines generated by inserting the small white areas
    image = cleanLines(image)

    # remove black areas from the image like corners formed by the stick and the stave line
    # or black areas coming from the tail of individual quavers
    # or coming from quarters attached to half's (the tiny tick bottom line)
    image = removeBlackAreas(image, 80)
    showImage(image,'Remove big black areas') if debug else None

    # find heads using template matching
    headTemplate = createKernelFromImage(noteHeadTemplate)
    headLocations = cv2.matchTemplate(image, headTemplate, cv2.TM_CCOEFF_NORMED)

    noteHeadPointsMask = findLocalMax(headLocations, 13, 0.4)
    showImage(noteHeadPointsMask, 'Find Local Max') if debug else None

    # when max point is in window border more than two points can be created
    # then, when two points are too close only pick the brightest
    noteHeadPoints = consolidatePoints(noteHeadPointsMask, 10)

    # translate matching point to center of template
    noteHeadPoints = [(x + headTemplate.shape[1] // 2, y + headTemplate.shape[0] // 2) for ((x, y), value) in
                      noteHeadPoints]

    if show:
        drawPoints(noteHeadPoints, og, fileName)

    # adjust the kernel template to meangap if needed

    return noteHeadPoints


# getFourHeadCenters works with the class: four
def getNoteHeadsFour(image, show=False, fileName='Four Head Detection', debug=False):
    og = image.copy()
    showImage(og, 'Original') if debug else None
    # convert to gray scale
    image = np.array(image)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

    image = thresh(image, 160)
    showImage(image, 'Threshold') if debug else None

    # sometimes the head is too close to the border and the inner white circle is not closed (figure391)
    # drawing a black 1pixel thick horizontal line closes the inner white circle in that scenario
    image = drawSingleLineUpAndDown(image)

    # filling the middle white circle helps with template matching
    image = fillWhiteHoles(image)
    showImage(image, 'Fill white holes') if debug else None

    # look for template match
    fourTemplate = createKernelFromImage(fourHeadTemplate)
    headLocations = cv2.matchTemplate(image, fourTemplate, cv2.TM_CCOEFF_NORMED)

    # find local maxima
    noteHeadPointsMask = findLocalMaxFour(headLocations, 13, 0.45)
    showImage(noteHeadPointsMask, 'Find local max') if debug else None

    noteHeadPoints = consolidatePoints(noteHeadPointsMask, 10)

    # translate matching point to center of template
    noteHeadPoints = [(x + fourTemplate.shape[1] // 2, y + fourTemplate.shape[0] // 2) for ((x, y), value) in
                      noteHeadPoints]

    if show:
        drawPoints(noteHeadPoints, og, fileName)

    return noteHeadPoints
